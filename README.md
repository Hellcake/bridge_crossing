# Симуляция проезда моста с односторонним движением

## 1. Введение

Данный проект представляет собой реализацию симуляции движения автомобилей через мост с односторонним движением. 

### Цель исследования:
Разработать и исследовать эффективность многопоточной реализации алгоритма управления движением автомобилей через мост с односторонним движением.

### Задачи:
- Реализовать однопоточную и многопоточную версии алгоритма
- Обеспечить корректное управление очередями автомобилей
- Внедрить механизм приоритетного проезда
- Провести сравнительный анализ производительности реализаций
- Обеспечить сбор и анализ статистики работы системы

## 2. Описание задачи

Система моделирует движение автомобилей через мост с односторонним движением. Основные требования:

- По мосту одновременно может проезжать только один автомобиль
- Движение возможно в обоих направлениях, но не одновременно
- Система должна обрабатывать одновременное прибытие автомобилей с разных сторон
- Необходимо предотвращать ситуации бесконечного ожидания (стагнации)

### Ключевые особенности реализации:
- Поддержка приоритетного направления движения
- Ограничение на количество последовательных проездов в одном направлении (3 машины)
- Сбор статистики по времени ожидания и проезда
- Логирование всех событий системы

## 3. Описание базового алгоритма

Базовый алгоритм работы системы включает следующие этапы:

```python
def cross(self, car_id: int, direction: Direction) -> Tuple[float, float]:
    """Метод для проезда автомобиля через мост"""
    arrival_time = time.time()
    
    with self.lock:
        # Добавляем машину в очередь
        self.waiting_queues[direction].append(car_id)
        
        # Ждем возможности проезда
        while not self.can_cross(car_id, direction):
            self.condition.wait()
        
        # Процесс проезда
        self.process_crossing(car_id, direction)
```

Основные этапы:
1. Прибытие автомобиля и постановка в очередь
2. Проверка возможности проезда
3. Ожидание (если проезд невозможен)
4. Проезд моста
5. Освобождение моста и обновление статистики

## 4. Описание основных процедур

### Многопоточная реализация

Ключевые компоненты многопоточной версии:

```python
class Bridge:
    def __init__(self, priority_direction: Optional[Direction] = None):
        self.lock = threading.Lock()  # Мьютекс для синхронизации
        self.condition = threading.Condition(self.lock)  # Условная переменная
        self.current_direction = None  # Текущее направление движения
        self.cars_on_bridge = 0  # Количество машин на мосту
        self.consecutive_cars = 0  # Счетчик последовательных машин
```

Каждый автомобиль представлен отдельным потоком:

```python
class Car(threading.Thread):
    def run(self):
        try:
            crossing_time, waiting_time = self.bridge.cross(
                self.car_id, 
                self.direction
            )
            self.crossed = True
            self.crossing_time = crossing_time
            self.waiting_time = waiting_time
        except Exception as e:
            logger.error(f"Ошибка при проезде моста: {e}")
```

### Механизм синхронизации:
- Использование мьютекса для исключения одновременного проезда
- Условная переменная для координации потоков
- Очереди для каждого направления

### Однопоточная реализация

Реализует тот же алгоритм, но без использования механизмов синхронизации:

```python
class SingleThreadedBridge:
    def simulate(self, cars_data: List[Tuple[float, int, Direction]]) -> Dict:
        current_time = 0.0
        
        # Распределяем машины по очередям
        for arrival_time, car_id, direction in sorted(cars_data):
            self.queues[direction].append((arrival_time, car_id))
        
        # Основной цикл симуляции
        while any(len(q) > 0 for q in self.queues.values()):
            direction, car_info = self.choose_next_car(current_time)
            if not direction or not car_info:
                break
            
            self.process_car(direction, car_info, current_time)
```

## 5. Результаты работы приложения

Система включает комплексное тестирование обеих реализаций:

1. **Базовые тесты**:
   - Проезд одиночного автомобиля
   - Блокировка встречного движения
   - Соблюдение приоритета направления
   - Ограничение последовательных проездов

2. **Интеграционные тесты**:
   - Полный цикл симуляции
   - Сравнение реализаций
   - Обработка ошибок
   - Одновременное прибытие автомобилей

3. **Метрики производительности**:
   - Общее количество проехавших машин
   - Среднее время проезда
   - Среднее время ожидания
   - Максимальное время ожидания
   - Статистика по направлениям

## 6. Анализ результатов работы

### Масштабируемость потоков

Многопоточная реализация демонстрирует следующие характеристики:

1. **Преимущества**:
   - Естественное моделирование параллельных прибытий
   - Обработка прибытий в реальном времени
   - Более реалистичная симуляция

2. **Сложности**:
   - Необходимость тщательной синхронизации
   - Потенциальные взаимоблокировки
   - Повышенное потребление ресурсов

### Влияние приоритетов

Система приоритетов влияет на:
- Выбор следующего автомобиля для проезда
- Время ожидания в разных направлениях
- Общую пропускную способность

### Основные выводы:

1. **Потокобезопасность**:
   - Корректная синхронизация предотвращает состояния гонки
   - Конкуренция за блокировки растет с числом машин

2. **Характеристики производительности**:
   - Многопоточная версия лучше справляется с динамическими прибытиями
   - Однопоточная версия имеет меньшие накладные расходы
   - Приоритетное направление улучшает поток для предпочтительного трафика

## 7. Выводы

1. **Архитектурные решения**:
   - Обе реализации успешно справляются с задачей
   - Обеспечена потокобезопасность в многопоточной версии
   - Правила приоритета эффективно управляют потоком

2. **Эффективность реализации**:
   - Модульная архитектура облегчает модификацию
   - Всестороннее тестирование обеспечивает надежность
   - Сбор статистики позволяет анализировать производительность

3. **Возможные улучшения**:
   - Динамическая настройка лимита последовательных машин
   - Более продвинутые алгоритмы планирования
   - Оптимизация производительности при высокой нагрузке

## 8. Структура кода

Проект имеет модульную структуру:

```
src/
├── models/
│   ├── bridge.py        # Реализация моста
│   ├── car.py          # Реализация автомобиля
│   └── direction.py    # Направления движения
├── simulation/
│   ├── scheduler.py    # Планировщик автомобилей
│   └── single_threaded.py # Однопоточная реализация
└── utils/
    ├── input_reader.py # Чтение входных данных
    └── logger.py       # Настройка логирования
```

Каждый модуль имеет четкую ответственность:
- `models/`: Основные объекты предметной области
- `simulation/`: Логика симуляции
- `utils/`: Вспомогательные утилиты

Код хорошо документирован, включает типизацию и подробные комментарии.
